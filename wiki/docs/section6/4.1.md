# select/epoll

## 为什么出现select
> 原始社会如果想实现高并发怎么办，只能每个请求开一个进程或者线程，但是系统资源是有限的奥，还有个问题是大部分fd活跃度非常低，占着资源不拉屎
  select实际是“io多路复用技术”，实际就是单个进程/线程就可以同时处理多个网络连接的io请求（同时阻塞多个io操作）

## epoll 解决什么问题
> 高并发的核心解决方案是1个线程处理所有连接的“等待消息准备好”，这一点上epoll和select是无争议的。但select预估错误了一件事，当数十万并发连接存在时，可能每一毫秒只有数百个活跃的连接，同时其余数十万连接在这一毫秒是非活跃的。select的使用方法是这样的：
  返回的活跃连接 ==select（全部待监控的连接）。什么时候会调用select方法呢？在你认为需要找出有报文到达的活跃连接时，就应该调用。所以，调用select在高并发时是会被频繁调用的。这样，这个频繁调用的方法就很有必要看看它是否有效率，因为，它的轻微效率损失都会被“频繁”二字所放大。它有效率损失吗？显而易见，全部待监控连接是数以十万计的，返回的只是数百个活跃连接，这本身就是无效率的表现。被放大后就会发现，处理并发上万个连接时，select就完全力不从心了

## epoll
  
